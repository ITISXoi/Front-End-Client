/* Autogenerated file. Do not edit manually. */

/* tslint:disable */

/* eslint-disable */
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";

export interface ABIInterface extends utils.Interface {
  functions: {
    "BASIS_POINT()": FunctionFragment;
    "collections(uint256)": FunctionFragment;
    "collectionsByArtist(address)": FunctionFragment;
    "createCollection(uint256,string,string,string,address,uint256,uint256,uint256)": FunctionFragment;
    "encodeData(uint256,address,uint256,uint256,string,bytes)": FunctionFragment;
    "feeTo()": FunctionFragment;
    "getNFTInfo(uint256,uint256)": FunctionFragment;
    "getNextTokenId(uint256)": FunctionFragment;
    "initialize(address,address,address,uint256,uint256)": FunctionFragment;
    "isLayerMinted(bytes)": FunctionFragment;
    "mintNFT(uint256,string,uint256,bytes,bytes)": FunctionFragment;
    "owner()": FunctionFragment;
    "premiumExpirations(address)": FunctionFragment;
    "premiumPackPrice()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "royaltyFee()": FunctionFragment;
    "royaltyFeeTo()": FunctionFragment;
    "setFeeTo(address)": FunctionFragment;
    "setPremiumPackPrice(uint256)": FunctionFragment;
    "setRoyaltyFee(uint256)": FunctionFragment;
    "setRoyaltyFeeTo(address)": FunctionFragment;
    "setVerifier(address)": FunctionFragment;
    "subscribePremiumPack()": FunctionFragment;
    "totalCollection()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "updateEndTime(uint256,uint256)": FunctionFragment;
    "updateMintCap(uint256,uint256)": FunctionFragment;
    "updateStartTime(uint256,uint256)": FunctionFragment;
    "verifier()": FunctionFragment;
    "verifyMessage(uint256,address,uint256,uint256,string,bytes,bytes)": FunctionFragment;
    "withdraw(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "BASIS_POINT"
      | "collections"
      | "collectionsByArtist"
      | "createCollection"
      | "encodeData"
      | "feeTo"
      | "getNFTInfo"
      | "getNextTokenId"
      | "initialize"
      | "isLayerMinted"
      | "mintNFT"
      | "owner"
      | "premiumExpirations"
      | "premiumPackPrice"
      | "renounceOwnership"
      | "royaltyFee"
      | "royaltyFeeTo"
      | "setFeeTo"
      | "setPremiumPackPrice"
      | "setRoyaltyFee"
      | "setRoyaltyFeeTo"
      | "setVerifier"
      | "subscribePremiumPack"
      | "totalCollection"
      | "transferOwnership"
      | "updateEndTime"
      | "updateMintCap"
      | "updateStartTime"
      | "verifier"
      | "verifyMessage"
      | "withdraw"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "BASIS_POINT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "collections",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "collectionsByArtist",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "createCollection",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "encodeData",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "feeTo", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getNFTInfo",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNextTokenId",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isLayerMinted",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "mintNFT",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "premiumExpirations",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "premiumPackPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "royaltyFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "royaltyFeeTo",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPremiumPackPrice",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setRoyaltyFee",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setRoyaltyFeeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setVerifier",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "subscribePremiumPack",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalCollection",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateEndTime",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateMintCap",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateStartTime",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "verifier", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "verifyMessage",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "BASIS_POINT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collections",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collectionsByArtist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createCollection",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "encodeData", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "feeTo", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getNFTInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getNextTokenId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isLayerMinted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mintNFT", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "premiumExpirations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "premiumPackPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "royaltyFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "royaltyFeeTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setFeeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setPremiumPackPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRoyaltyFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRoyaltyFeeTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setVerifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "subscribePremiumPack",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalCollection",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateEndTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateMintCap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateStartTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "verifier", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "verifyMessage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "CollectionCreated(uint256,uint256,string,string,string,address,address,address,uint256)": EventFragment;
    "EndTimeUpdated(uint256,uint256,uint256)": EventFragment;
    "FeeToAddressChanged(address,address)": EventFragment;
    "MintCapUpdated(uint256,uint256,uint256)": EventFragment;
    "NFTMinted(uint256,address,address,string,uint256,uint256)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "PremiumPackPriceChanged(uint256,uint256)": EventFragment;
    "PremiumPackSubscribed(address,uint256)": EventFragment;
    "RoyaltyFeeChanged(uint256,uint256)": EventFragment;
    "RoyaltyFeeToAddressChanged(address,address)": EventFragment;
    "StartTimeUpdated(uint256,uint256,uint256)": EventFragment;
    "VerifierAddressChanged(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CollectionCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EndTimeUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FeeToAddressChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MintCapUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTMinted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PremiumPackPriceChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PremiumPackSubscribed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoyaltyFeeChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoyaltyFeeToAddressChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StartTimeUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VerifierAddressChanged"): EventFragment;
}

export interface CollectionCreatedEventObject {
  keyId: BigNumber;
  collectionId: BigNumber;
  name: string;
  symbol: string;
  baseUri: string;
  artist: string;
  collectionAddress: string;
  paymentToken: string;
  mintCap: BigNumber;
}
export type CollectionCreatedEvent = TypedEvent<
  [
    BigNumber,
    BigNumber,
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber
  ],
  CollectionCreatedEventObject
>;

export type CollectionCreatedEventFilter =
  TypedEventFilter<CollectionCreatedEvent>;

export interface EndTimeUpdatedEventObject {
  collectionId: BigNumber;
  oldEndTime: BigNumber;
  newEndTime: BigNumber;
}
export type EndTimeUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  EndTimeUpdatedEventObject
>;

export type EndTimeUpdatedEventFilter = TypedEventFilter<EndTimeUpdatedEvent>;

export interface FeeToAddressChangedEventObject {
  oldAddress: string;
  newAddress: string;
}
export type FeeToAddressChangedEvent = TypedEvent<
  [string, string],
  FeeToAddressChangedEventObject
>;

export type FeeToAddressChangedEventFilter =
  TypedEventFilter<FeeToAddressChangedEvent>;

export interface MintCapUpdatedEventObject {
  collectionId: BigNumber;
  oldMintCap: BigNumber;
  newMintCap: BigNumber;
}
export type MintCapUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  MintCapUpdatedEventObject
>;

export type MintCapUpdatedEventFilter = TypedEventFilter<MintCapUpdatedEvent>;

export interface NFTMintedEventObject {
  collectionId: BigNumber;
  collectionAddress: string;
  receiver: string;
  uri: string;
  tokenId: BigNumber;
  royaltyFee: BigNumber;
}
export type NFTMintedEvent = TypedEvent<
  [BigNumber, string, string, string, BigNumber, BigNumber],
  NFTMintedEventObject
>;

export type NFTMintedEventFilter = TypedEventFilter<NFTMintedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PremiumPackPriceChangedEventObject {
  oldPrice: BigNumber;
  newPrice: BigNumber;
}
export type PremiumPackPriceChangedEvent = TypedEvent<
  [BigNumber, BigNumber],
  PremiumPackPriceChangedEventObject
>;

export type PremiumPackPriceChangedEventFilter =
  TypedEventFilter<PremiumPackPriceChangedEvent>;

export interface PremiumPackSubscribedEventObject {
  userAddress: string;
  expirationTime: BigNumber;
}
export type PremiumPackSubscribedEvent = TypedEvent<
  [string, BigNumber],
  PremiumPackSubscribedEventObject
>;

export type PremiumPackSubscribedEventFilter =
  TypedEventFilter<PremiumPackSubscribedEvent>;

export interface RoyaltyFeeChangedEventObject {
  oldFee: BigNumber;
  newFee: BigNumber;
}
export type RoyaltyFeeChangedEvent = TypedEvent<
  [BigNumber, BigNumber],
  RoyaltyFeeChangedEventObject
>;

export type RoyaltyFeeChangedEventFilter =
  TypedEventFilter<RoyaltyFeeChangedEvent>;

export interface RoyaltyFeeToAddressChangedEventObject {
  oldAddress: string;
  newAddress: string;
}
export type RoyaltyFeeToAddressChangedEvent = TypedEvent<
  [string, string],
  RoyaltyFeeToAddressChangedEventObject
>;

export type RoyaltyFeeToAddressChangedEventFilter =
  TypedEventFilter<RoyaltyFeeToAddressChangedEvent>;

export interface StartTimeUpdatedEventObject {
  collectionId: BigNumber;
  oldStartTime: BigNumber;
  newStartTime: BigNumber;
}
export type StartTimeUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  StartTimeUpdatedEventObject
>;

export type StartTimeUpdatedEventFilter =
  TypedEventFilter<StartTimeUpdatedEvent>;

export interface VerifierAddressChangedEventObject {
  oldAddress: string;
  newAddress: string;
}
export type VerifierAddressChangedEvent = TypedEvent<
  [string, string],
  VerifierAddressChangedEventObject
>;

export type VerifierAddressChangedEventFilter =
  TypedEventFilter<VerifierAddressChangedEvent>;

export interface ABI extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ABIInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    BASIS_POINT(overrides?: CallOverrides): Promise<[BigNumber]>;

    collections(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, string, string, BigNumber, BigNumber, BigNumber] & {
        keyId: BigNumber;
        artist: string;
        collectionAddress: string;
        paymentToken: string;
        mintCap: BigNumber;
        startTime: BigNumber;
        endTime: BigNumber;
      }
    >;

    collectionsByArtist(
      artist: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    createCollection(
      keyId: PromiseOrValue<BigNumberish>,
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseUri: PromiseOrValue<string>,
      paymentToken: PromiseOrValue<string>,
      mintCap: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    encodeData(
      collectionID: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      layerHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    feeTo(overrides?: CallOverrides): Promise<[string]>;

    getNFTInfo(
      collectionId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string, string]>;

    getNextTokenId(
      collectionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    initialize(
      _feeTo: PromiseOrValue<string>,
      _verifier: PromiseOrValue<string>,
      _royaltyFeeTo: PromiseOrValue<string>,
      _royaltyFee: PromiseOrValue<BigNumberish>,
      _premiumPackPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isLayerMinted(
      layerHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    mintNFT(
      collectionId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      layerHash: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    premiumExpirations(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    premiumPackPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    royaltyFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    royaltyFeeTo(overrides?: CallOverrides): Promise<[string]>;

    setFeeTo(
      _feeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPremiumPackPrice(
      _premiumPackPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRoyaltyFee(
      _royaltyFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRoyaltyFeeTo(
      _royaltyFeeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setVerifier(
      _verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    subscribePremiumPack(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    totalCollection(overrides?: CallOverrides): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateEndTime(
      collectionId: PromiseOrValue<BigNumberish>,
      _endTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateMintCap(
      collectionId: PromiseOrValue<BigNumberish>,
      _mintCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateStartTime(
      collectionId: PromiseOrValue<BigNumberish>,
      _startTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    verifier(overrides?: CallOverrides): Promise<[string]>;

    verifyMessage(
      collectionID: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      layerHash: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    withdraw(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

  collections(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, string, string, string, BigNumber, BigNumber, BigNumber] & {
      keyId: BigNumber;
      artist: string;
      collectionAddress: string;
      paymentToken: string;
      mintCap: BigNumber;
      startTime: BigNumber;
      endTime: BigNumber;
    }
  >;

  collectionsByArtist(
    artist: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  createCollection(
    keyId: PromiseOrValue<BigNumberish>,
    name: PromiseOrValue<string>,
    symbol: PromiseOrValue<string>,
    baseUri: PromiseOrValue<string>,
    paymentToken: PromiseOrValue<string>,
    mintCap: PromiseOrValue<BigNumberish>,
    startTime: PromiseOrValue<BigNumberish>,
    endTime: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  encodeData(
    collectionID: PromiseOrValue<BigNumberish>,
    sender: PromiseOrValue<string>,
    fee: PromiseOrValue<BigNumberish>,
    tokenId: PromiseOrValue<BigNumberish>,
    uri: PromiseOrValue<string>,
    layerHash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  feeTo(overrides?: CallOverrides): Promise<string>;

  getNFTInfo(
    collectionId: PromiseOrValue<BigNumberish>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[string, string]>;

  getNextTokenId(
    collectionId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  initialize(
    _feeTo: PromiseOrValue<string>,
    _verifier: PromiseOrValue<string>,
    _royaltyFeeTo: PromiseOrValue<string>,
    _royaltyFee: PromiseOrValue<BigNumberish>,
    _premiumPackPrice: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isLayerMinted(
    layerHash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  mintNFT(
    collectionId: PromiseOrValue<BigNumberish>,
    uri: PromiseOrValue<string>,
    fee: PromiseOrValue<BigNumberish>,
    layerHash: PromiseOrValue<BytesLike>,
    signature: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  premiumExpirations(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  premiumPackPrice(overrides?: CallOverrides): Promise<BigNumber>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  royaltyFee(overrides?: CallOverrides): Promise<BigNumber>;

  royaltyFeeTo(overrides?: CallOverrides): Promise<string>;

  setFeeTo(
    _feeTo: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPremiumPackPrice(
    _premiumPackPrice: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRoyaltyFee(
    _royaltyFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRoyaltyFeeTo(
    _royaltyFeeTo: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setVerifier(
    _verifier: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  subscribePremiumPack(
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  totalCollection(overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateEndTime(
    collectionId: PromiseOrValue<BigNumberish>,
    _endTime: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateMintCap(
    collectionId: PromiseOrValue<BigNumberish>,
    _mintCap: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateStartTime(
    collectionId: PromiseOrValue<BigNumberish>,
    _startTime: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  verifier(overrides?: CallOverrides): Promise<string>;

  verifyMessage(
    collectionID: PromiseOrValue<BigNumberish>,
    sender: PromiseOrValue<string>,
    fee: PromiseOrValue<BigNumberish>,
    tokenId: PromiseOrValue<BigNumberish>,
    uri: PromiseOrValue<string>,
    layerHash: PromiseOrValue<BytesLike>,
    signature: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  withdraw(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

    collections(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, string, string, BigNumber, BigNumber, BigNumber] & {
        keyId: BigNumber;
        artist: string;
        collectionAddress: string;
        paymentToken: string;
        mintCap: BigNumber;
        startTime: BigNumber;
        endTime: BigNumber;
      }
    >;

    collectionsByArtist(
      artist: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    createCollection(
      keyId: PromiseOrValue<BigNumberish>,
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseUri: PromiseOrValue<string>,
      paymentToken: PromiseOrValue<string>,
      mintCap: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    encodeData(
      collectionID: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      layerHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    feeTo(overrides?: CallOverrides): Promise<string>;

    getNFTInfo(
      collectionId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string, string]>;

    getNextTokenId(
      collectionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      _feeTo: PromiseOrValue<string>,
      _verifier: PromiseOrValue<string>,
      _royaltyFeeTo: PromiseOrValue<string>,
      _royaltyFee: PromiseOrValue<BigNumberish>,
      _premiumPackPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    isLayerMinted(
      layerHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    mintNFT(
      collectionId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      layerHash: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    owner(overrides?: CallOverrides): Promise<string>;

    premiumExpirations(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    premiumPackPrice(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    royaltyFee(overrides?: CallOverrides): Promise<BigNumber>;

    royaltyFeeTo(overrides?: CallOverrides): Promise<string>;

    setFeeTo(
      _feeTo: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPremiumPackPrice(
      _premiumPackPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRoyaltyFee(
      _royaltyFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRoyaltyFeeTo(
      _royaltyFeeTo: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setVerifier(
      _verifier: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    subscribePremiumPack(overrides?: CallOverrides): Promise<void>;

    totalCollection(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateEndTime(
      collectionId: PromiseOrValue<BigNumberish>,
      _endTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateMintCap(
      collectionId: PromiseOrValue<BigNumberish>,
      _mintCap: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateStartTime(
      collectionId: PromiseOrValue<BigNumberish>,
      _startTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    verifier(overrides?: CallOverrides): Promise<string>;

    verifyMessage(
      collectionID: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      layerHash: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    withdraw(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "CollectionCreated(uint256,uint256,string,string,string,address,address,address,uint256)"(
      keyId?: null,
      collectionId?: null,
      name?: null,
      symbol?: null,
      baseUri?: null,
      artist?: null,
      collectionAddress?: null,
      paymentToken?: null,
      mintCap?: null
    ): CollectionCreatedEventFilter;
    CollectionCreated(
      keyId?: null,
      collectionId?: null,
      name?: null,
      symbol?: null,
      baseUri?: null,
      artist?: null,
      collectionAddress?: null,
      paymentToken?: null,
      mintCap?: null
    ): CollectionCreatedEventFilter;

    "EndTimeUpdated(uint256,uint256,uint256)"(
      collectionId?: PromiseOrValue<BigNumberish> | null,
      oldEndTime?: null,
      newEndTime?: null
    ): EndTimeUpdatedEventFilter;
    EndTimeUpdated(
      collectionId?: PromiseOrValue<BigNumberish> | null,
      oldEndTime?: null,
      newEndTime?: null
    ): EndTimeUpdatedEventFilter;

    "FeeToAddressChanged(address,address)"(
      oldAddress?: null,
      newAddress?: null
    ): FeeToAddressChangedEventFilter;
    FeeToAddressChanged(
      oldAddress?: null,
      newAddress?: null
    ): FeeToAddressChangedEventFilter;

    "MintCapUpdated(uint256,uint256,uint256)"(
      collectionId?: PromiseOrValue<BigNumberish> | null,
      oldMintCap?: null,
      newMintCap?: null
    ): MintCapUpdatedEventFilter;
    MintCapUpdated(
      collectionId?: PromiseOrValue<BigNumberish> | null,
      oldMintCap?: null,
      newMintCap?: null
    ): MintCapUpdatedEventFilter;

    "NFTMinted(uint256,address,address,string,uint256,uint256)"(
      collectionId?: PromiseOrValue<BigNumberish> | null,
      collectionAddress?: null,
      receiver?: null,
      uri?: null,
      tokenId?: null,
      royaltyFee?: null
    ): NFTMintedEventFilter;
    NFTMinted(
      collectionId?: PromiseOrValue<BigNumberish> | null,
      collectionAddress?: null,
      receiver?: null,
      uri?: null,
      tokenId?: null,
      royaltyFee?: null
    ): NFTMintedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "PremiumPackPriceChanged(uint256,uint256)"(
      oldPrice?: null,
      newPrice?: null
    ): PremiumPackPriceChangedEventFilter;
    PremiumPackPriceChanged(
      oldPrice?: null,
      newPrice?: null
    ): PremiumPackPriceChangedEventFilter;

    "PremiumPackSubscribed(address,uint256)"(
      userAddress?: PromiseOrValue<string> | null,
      expirationTime?: null
    ): PremiumPackSubscribedEventFilter;
    PremiumPackSubscribed(
      userAddress?: PromiseOrValue<string> | null,
      expirationTime?: null
    ): PremiumPackSubscribedEventFilter;

    "RoyaltyFeeChanged(uint256,uint256)"(
      oldFee?: null,
      newFee?: null
    ): RoyaltyFeeChangedEventFilter;
    RoyaltyFeeChanged(
      oldFee?: null,
      newFee?: null
    ): RoyaltyFeeChangedEventFilter;

    "RoyaltyFeeToAddressChanged(address,address)"(
      oldAddress?: null,
      newAddress?: null
    ): RoyaltyFeeToAddressChangedEventFilter;
    RoyaltyFeeToAddressChanged(
      oldAddress?: null,
      newAddress?: null
    ): RoyaltyFeeToAddressChangedEventFilter;

    "StartTimeUpdated(uint256,uint256,uint256)"(
      collectionId?: PromiseOrValue<BigNumberish> | null,
      oldStartTime?: null,
      newStartTime?: null
    ): StartTimeUpdatedEventFilter;
    StartTimeUpdated(
      collectionId?: PromiseOrValue<BigNumberish> | null,
      oldStartTime?: null,
      newStartTime?: null
    ): StartTimeUpdatedEventFilter;

    "VerifierAddressChanged(address,address)"(
      oldAddress?: null,
      newAddress?: null
    ): VerifierAddressChangedEventFilter;
    VerifierAddressChanged(
      oldAddress?: null,
      newAddress?: null
    ): VerifierAddressChangedEventFilter;
  };

  estimateGas: {
    BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

    collections(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    collectionsByArtist(
      artist: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createCollection(
      keyId: PromiseOrValue<BigNumberish>,
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseUri: PromiseOrValue<string>,
      paymentToken: PromiseOrValue<string>,
      mintCap: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    encodeData(
      collectionID: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      layerHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    feeTo(overrides?: CallOverrides): Promise<BigNumber>;

    getNFTInfo(
      collectionId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNextTokenId(
      collectionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      _feeTo: PromiseOrValue<string>,
      _verifier: PromiseOrValue<string>,
      _royaltyFeeTo: PromiseOrValue<string>,
      _royaltyFee: PromiseOrValue<BigNumberish>,
      _premiumPackPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isLayerMinted(
      layerHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mintNFT(
      collectionId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      layerHash: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    premiumExpirations(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    premiumPackPrice(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    royaltyFee(overrides?: CallOverrides): Promise<BigNumber>;

    royaltyFeeTo(overrides?: CallOverrides): Promise<BigNumber>;

    setFeeTo(
      _feeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPremiumPackPrice(
      _premiumPackPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRoyaltyFee(
      _royaltyFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRoyaltyFeeTo(
      _royaltyFeeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setVerifier(
      _verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    subscribePremiumPack(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    totalCollection(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateEndTime(
      collectionId: PromiseOrValue<BigNumberish>,
      _endTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateMintCap(
      collectionId: PromiseOrValue<BigNumberish>,
      _mintCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateStartTime(
      collectionId: PromiseOrValue<BigNumberish>,
      _startTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    verifier(overrides?: CallOverrides): Promise<BigNumber>;

    verifyMessage(
      collectionID: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      layerHash: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdraw(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    BASIS_POINT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    collections(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collectionsByArtist(
      artist: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createCollection(
      keyId: PromiseOrValue<BigNumberish>,
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseUri: PromiseOrValue<string>,
      paymentToken: PromiseOrValue<string>,
      mintCap: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    encodeData(
      collectionID: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      layerHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    feeTo(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getNFTInfo(
      collectionId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNextTokenId(
      collectionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      _feeTo: PromiseOrValue<string>,
      _verifier: PromiseOrValue<string>,
      _royaltyFeeTo: PromiseOrValue<string>,
      _royaltyFee: PromiseOrValue<BigNumberish>,
      _premiumPackPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isLayerMinted(
      layerHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    mintNFT(
      collectionId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      layerHash: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    premiumExpirations(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    premiumPackPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    royaltyFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    royaltyFeeTo(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setFeeTo(
      _feeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPremiumPackPrice(
      _premiumPackPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRoyaltyFee(
      _royaltyFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRoyaltyFeeTo(
      _royaltyFeeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setVerifier(
      _verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    subscribePremiumPack(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    totalCollection(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateEndTime(
      collectionId: PromiseOrValue<BigNumberish>,
      _endTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateMintCap(
      collectionId: PromiseOrValue<BigNumberish>,
      _mintCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateStartTime(
      collectionId: PromiseOrValue<BigNumberish>,
      _startTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    verifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    verifyMessage(
      collectionID: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      uri: PromiseOrValue<string>,
      layerHash: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    withdraw(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
